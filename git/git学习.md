# 01-git-commit

> Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！
>
> Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。
>
> Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。

> 总结:每次commit都会在原来分支进行更新,对比上次的版本,发布当前版本,那些commit就像历史记录一样,我们随时可以去查看
>
> `git commit -m "提交的描述信息"`

# 02-git-branch

> 主要是帮助我们进行分开管理,较为方便
>
> 创建一个新分支
>
> `git checkout "新分支"`
>
> 下面是新建完分支后,快速切换到新分支上去
>
> `git checkout -b "新分支"`
>
> `git branch -d "需要删除的分支"`

# 03-git-merge

> 将分支上的新功能合并到主分支上去,他们合并完之后,会将之前的所有提交修改都放在一起
>
> 当他们合并完之后,在后续没做过任何改动的情况下,如果想把master的分支合并到新功能分支上去的时候,仅仅只是将原来分支指向了当前的master所指向的那个提交记录.
>
> 比如在master合并新功能分支,就要像下面这样
>
> `git merge "想要合并的分支"`

# 04-git-rebase

> Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。
>
> Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。
>
> 
>
> `git rebase "你想要rebase的分支"`

# 05-git-HEAD

> HEAD是一个对当前检出记录的符号引用----------也就是指向你正在基础上进行工作的提交记录
>
> HEAD总是指向当前分支上最近一次提交记录.大多数修改提交树的Git命令是从改变Head的指向改变的
>
> 想查看HEAD指向   `cat.git/HEAD`
>
> 如果HEAD指向的是一个引用,还可以使用   `git symbolic-ref HEAD`查看它的指向



> 要想切换HEAD指向 的使用提交名字而不是分支名
>
> `git checkout "提交名字不是分支名"`

# 06-相对引用

> 两个简单的用法
>
> 1. `^`向上移动1个提交记录
> 2. 使用 `~<num>`向上移动多个记录,例如 `~3`
>
> 强制修改分支,强制转换是根据HEAD的指向来执行的
>
> `git branch -f master`

# 07-撤销更改

> 撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。
>
> 1. `git reset`
>
>    `git reset` 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。`git reset` 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。
>
> 2. `git revert`
>
>    上面那个方法只对本地有用,要想在大家使用的远程修改分支,我们得使用这个命令
>
>    使用后他会创建一个新的提交,这个新的提交内会引入更改,这个更改就是用来撤销那个提交的,也就是说那个状态就和提交之前的那个状态相同
>
> 

# 08-整理提交记录

> 这个是你可以把所有你想要的分支放到当前的分支下
>
> `git cherry-pick <提交号>`
>
> 这个指令可以帮助你调整提交记录的顺序,也可以删除某些提交,也可以合并某些提交
>
> `git rebase -i HEAD~4`
>
> 

# 09-本地栈式提交

> 来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。
>
> 这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！
>
> 最后就差把 `bugFix` 分支里的工作合并回 `master` 分支了。你可以选择通过 fast-forward 快速合并到 `master` 分支上，但这样的话 `master` 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……
>
> 这种的可以使用
>
> `git rebase -i `先将自己不需要提交的剔除
>
> `git rebase`合并分支
>
> 这样子就能解决问题了

# 10-git-Tag

> git-tag是用来位某个特定的提交命名为里程碑,然后就可以像分支一样引用了
>
> 它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。
>
> `git tag v1 C1`
>
> 我们将这个标签命名为 `v1`，并且明确地让它指向提交记录 `C1`，如果你不指定提交记录，Git 会用 `HEAD` 所指向的位置。
>
> Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签)
>
> `git describe` 
>
> 当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。
>
> `git describe` 的语法是：
>
> ```
> git describe <ref>
> ```
>
> `<ref>` 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（`HEAD`）。
>
> 它输出的结果是这样的：
>
> ```
> <tag>_<numCommits>_g<hash>
> ```
>
> `tag` 表示的是离 `ref` 最近的标签， `numCommits` 是表示这个 `ref` 与 `tag` 相差有多少个提交记录， `hash` 表示的是你所给定的 `ref` 所表示的提交记录哈希值的前几位。
>
> 当 `ref` 提交记录上有某个标签时，则只输出标签名称

# 11-开始远程仓库了

## 01-git clone

## 02-git-fetch

> 是用来获取远程仓库的最新数据
>
> `git fetch` 完成了仅有的但是很重要的两步:
>
> - 从远程仓库下载本地仓库中缺失的提交记录
> - 更新远程分支指针(如 `o/master`)
>
> `git fetch` 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。
>
> 如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，`git fetch` 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 `git fetch` 与远程分支之间的关系了吧。
>
> `git fetch` 通常通过互联网（使用 `http://` 或 `git://` 协议) 与远程仓库通信。
>
> 他只是一个单纯的下载功能,但是不会更新你本地的状态

## 03-git-pull

> ## Git Pull
>
> 既然我们已经知道了如何用 `git fetch` 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。
>
> 其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:
>
> - `git cherry-pick o/master`
> - `git rebase o/master`
> - `git merge o/master`
> - 等等
>
> 实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 `git pull`。