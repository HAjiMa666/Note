# 前言

在代码的执行过程中,都是需要给代码分配内存的,而内存空间是有限的

# JS的内存管理

1. JS对于**基本数据类型内存的分配在执行时,直接在栈空间进行分配**
2. JS对于**复杂数据类型**内存分配会在堆内存中开辟一块空间,并且将这块空间的指针返回值变量引用

# JS的垃圾回收

> 垃圾回收的英文  Garbage Colloection 简称GC
>
> 这里有一篇推文写的很好,自己忘记了可以上这里看看
>
> [详解V8回收机制](https://mp.weixin.qq.com/s/VbAUPGt3sUVzEQHxWYmlBw)
>
> 下面是V8官方对于并发标记的一个详细介绍,自己可以去看下
>
> [Concurrent marking in V8 · V8](https://v8.dev/blog/concurrent-marking)

1. 引用计数

   > 当一个对象有一个引用指向它时，那么这个对象的引用就+1，当一个对象的引用为0时，这个对象就可以被销 毁掉；
   >
   > 这个算法有一个很大的弊端就是会产生循环引用

2. 标记清除

   > 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对 于哪些没有引用到的对象，就认为是不可用的对象；
   >
   > 这个算法可以很好的解决循环引用的问题

   1. 标记清除是对老生代内存回收时使用的算法,标记清除分为两步
      1. 标记:会从根(可以看做是window)开始标记所有可以访问到的对象,将其标记为活动对象
      2. 清除:会将所有未标记的对象进行一次回收
   2. 标记清除会产生内存碎片,所有标记清除后,还会有一次标记整理,因为不进行整理的话,当有新生代内存的中的对象晋升到老生代内存时或出现内存不够分配的情况,标记整理会将堆中所有存活的对象移动到另一端,这个移动时比较耗时的操作,所以一般老生代的内存都是使用标记清除,只有新生代内存中的对象晋升到老生代内存出现内存不够的情况下才会标记整理
   3. 因为JS是单线程的,后来V8引入了增量标记,即不需要一次性标记堆中所有的对象,变成一次性只标记部分对象,然后将控制器交给主线程,在主线程空闲时再进行标记

# 闭包

 ## 了解JS中的函数

> 在JavaScript中，函数是非常重要的，并且是一等公民
>
> 1. 函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用；
> 2. 自己编写高阶函数
> 3. 使用内置的高阶函数

函数的几种用法

1. 函数可以传递参数

   1. 可以传递任意类型数据作为参数

   2. 函数可以传递函数作为参数,最常用的是我们可以使用这个特性去编写更加灵活的一些工具函数

      ```js
      function calc(num1, num2, calcFn) {
        console.log(calcFn(num1, num2))
      }
      
      function add(num1, num2) {
        return num1 + num2
      }
      
      function sub(num1, num2) {
        return num1 - num2
      }
      
      function mul(num1, num2) {
        return num1 * num2
      }
      ```

2. js允许函数内部定义函数




 ## JS中的高阶函数补充

1. filter函数的使用(根据条件判断返回一个新的满足条件的数组)

2. map函数的使用(会根据条件对数组进行处理,返回新数组)

3. forEach函数是没有返回值的,是对数组进行遍历的

4. reduce 累加函数

5. find/findIndex find:返回元素 findIndex:返回元素索引



## 闭包概念

<h3>❗重要

在这个定义内,我们注意以下几个点,当我们理解了以下的几个点后,再把图中的概念通读一遍,应该就能彻底理解JS中的闭包了

1. 闭包的基本概念
2. 头等函数的概念
3. ❗❗❗自由变量的概念

![image-20210904092557602](https://gitee.com/IU_czx/images/raw/master/img/%E9%97%AD%E5%8C%85%E6%A6%82%E5%BF%B5.png)

<h3 style="color:skyblue">为什么JS函数是一等公民

![image-20210904092939794](https://gitee.com/IU_czx/images/raw/master/img/%E4%B8%BA%E4%BB%80%E4%B9%88JS%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91.png)

同时这也是头等函数的意思,头等函数是这个意思,满足上面的条件就是头等函数

<h3>针对闭包的产生,我专门录制了一个讲解视频,自己去看

## 内存泄漏

在我们了解了闭包的概念之后,我们就很清楚内存泄漏是怎么产生的了

要解决的最好办法就是将那些不用的变量设为null,就能很好多的解决这些问题

<h3 style="color:skyblue">如何检测内存泄漏</h3>

用下面这段代码跑一下,看浏览器中的performance性能分析

不过很难观测,大概知道怎么进行的就行

```js
function createFnArray(){
    // new Array可以给数组定义特定数组
    //fill:可以给这哥数组所有位置填充默认值
	var arr=new Array(1024*1024).fill(1)
    return function(){
       console.log(arr.length);
    }
}

var fnArr=[];
for(let i=0;i<100;i++){
    fnArr.push(createFnArray());
}
```

## 闭包引用的自由变量销毁

> 如果产生闭包后,那么被指向的上层AO对象是没有被销毁的
>
> 那么,AO对象内的没有被引用到的变量会被销毁吗?
>
> 答案是会的

虽然AO对象没有被销毁,但是JS引擎他会识别,并且将没有产生闭包的自由变量进行销毁,只留下与被绑定的自由变量
