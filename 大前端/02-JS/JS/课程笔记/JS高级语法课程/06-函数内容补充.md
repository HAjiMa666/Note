## 函数内容补充

### 1.with

   ```js
   with(obj){}
   ```

   会形成一个自己的作用域

   传入一个对象,作用域和正常情况不一样,他会先去寻找obj中的变量

   **不推荐使用**

   * 可能会出兼容性问题,和调试比较困难

### **2.eval**

   ```js
   var test="var message="ssss";";
   eval(test);
   ```

   `eval`可以接收字符串,并且执行字符串中的代码

   但是也不推荐使用

   1. 可读性差
   2. 容易被篡改
   3. eval执行的代码必须经过JS解释器,不能被JS引擎优化,效率会比较低

### 3.**严格模式**

   * 是一种具有限制性的JavaScript模式.从而使得代码隐式的脱离了"懒散(sloppy)"模式
   * 支持严格模式的浏览器在检测到代码中有严格模式时,会以更加严格的方式对代码进行检测和执行

严格模式对正常的JavaScript语义进行了一些限制

1. 严格模式通过抛出错误 来消除一些原有的静默(slient)错误

   * 静默错误是以前在写时,如果有这种true.name=""类似的错误,这种错误不会影响运行,所以之前会进行一个忽略,开启严格模式,会对这种抛出错误
2. 严格模式让JS引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）
3. 严格模式禁用了在ECMAScript未来版本中可能会定义的一些语法

开启严格模式的几种方式

1. 在JS文件作用域上加上`"use strict"`直接加在顶部就是全局严格,加在局部作用域上局部严格
2. 打包工具会帮我们加上严格模式

严格模式的限制

1. 无法意外的创建全局变量 
2. 严格模式会使引起静默失败(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常
3. 严格模式下试图删除不可删除的属性 
4. 严格模式不允许函数参数有相同的名称 
5. 不允许0的八进制语法 
6. 在严格模式下，不允许使用with 
7. 在严格模式下，eval不再为上层引用变量
8. 严格模式下，this绑定不会默认转成对象

```js
"use strict";
// 意外变量创建
function foo() {
    message = 10;
}

// 不允许函数有相同的参数名称
function foo2(x, y, x) { }

// 静默错误
// true.name="";
// NaN=123
// 等等....

// 不允许使用原先的8进制
// ES6最新标准 可以这么用
var num = 0o123; //八进制
var name2 = 0x123; //16进制
var name3 = 0b100 //二进制


// 开启严格模式后,独立函数调用的this指向的是window

function foo() {
    console.log(this);//undefined;
}

setTimeout(function () {
    // 它是内部调用的apply,绑定了this
    console.log(this);//window
}, 1000)
```



