# 闭包

## 闭包面试题一

```js
function fun(n, o) {
    console.log(o);
    return {
        fun: function (m) {
            return fun(m, n);
        }
    };
}

var a = fun(0);  //undefined
a.fun(1); //0
a.fun(2); //0
a.fun(3); //0
var b = fun(0).fun(1).fun(2).fun(3);  // undefined 0 1 2
```

分析:我们来看下这道题

1. 首先`var a=fun(0)` 这个时候调用`fun`函数,o这个时候是没有值的,那么`console.log`输出的值就是undefined

2. 第一次调用完之后,其实是产生闭包了

   1. 在函数执行的时候
   2. 返回的对象才会被创建
   3. 对象在被创建的时候,对象中的函数内存空间被创建
   4. 对象的内存空间被创建,自由变量被捕捉,此时产生闭包

3. `a.fun(1)`这个时候去调用,输出的值不再是`undefined`了,因为他会去找父级作用域,也就是上次的AO对象,那里存在o  的值,也就是0,所以输出为0
   请大家仔细看清楚,我们第一次传入的n值是被当作fun函数的第二个参数抓住的,也就是fun函数的`o`变量

4. `a.fun(2)`同理.o的值并没有发生改变 所以输出还是0

5. `a.fun(3)`同理.o的值并没有发生改变 所以输出还是0

6. `var b = fun(0).fun(1).fun(2).fun(3);`这个就不一样了

   我们来分析一下

   fun(0)执行调用,输出为undefined

   第一个fun(0)成为了fun(1)的父级作用域,那么输出为0

   第二个fun(1)成为了fun(2)的父级作用域,那么o的值发生了改变,变成了1,那么理所应当,输出的为1

   第三个fun(2)成为了fun(3)的父级作用域,那么o的值发生了改变,变成了2,那么输出的是2

# Dom事件流

## 01-如何让事件先冒泡后捕获

在DOM标准事件模型中,是先`捕获`后`冒泡`

但是如果要实现先`冒泡`后`捕获`的效果

对于同一个事件,监听`捕获`和`冒泡`

分别对应相应的处理函数,监听到捕获事件,先暂缓执行,直到冒泡事件被捕获后再执行捕获之间

## 02-介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数

- 按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段

- 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数

  - 注意1：前提是事件被确实触发
  - 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”

- 事件执行顺序：判断的关键是否目标元素

  - 非目标元素：根据W3C的标准执行：捕获->目标元素->冒泡（不依据事件绑定顺序）

  - 目标元素：依据事件绑定顺序：先绑定的事件先执行

    如果既有冒泡,也有捕获,会先执行捕获事件,在按顺序执行冒泡事件

  - 最终顺序：父元素捕获->目标元素事件1->目标元素事件2->子元素捕获->子元素冒泡->父元素冒泡

  - 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系

- ![image-20210914101204014](https://gitee.com/IU_czx/images/raw/master/img/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F.png)