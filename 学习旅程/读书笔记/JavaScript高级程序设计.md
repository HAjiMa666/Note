# 第一章  什么是JavaScript

## JavaScript组成

> JavaScript由ECMAScript,DOM,BOM三者组成
>
> 1. ECMAScript
> 2. DOM
> 3. BOM

## ECMAScript

> 它是由ECMA-262定义的语言
>
> 这门语言没有输入和输出之类的方法
>
> web浏览器只是它实现可能存在的一种宿主环境（host environment）

这门语言定义了：

1. 语法
2. 类型
3. 语句
4. 关键字
5. 保留字
6. 操作符
7. 全局对象

## DOM

> 　文档对象模型(DOM Document Object Model)是一个应用程序接口(API),用于在HTML中使用扩展的XML

DOM并非只能通过JavaScript来实现,而且也被其他很多语言实现了

## BOM

> 浏览器对象模型API,用于支持访问和操作浏览器的窗口
>
> 它真正独一无二的地方,当然也是问题最多的地方,他是唯一一个没有相关标准的JavaScript实现
>
> HTML5出现后,这个问题就解决了

BOM的范畴

1. 弹出新浏览器的能力
2. 移动,缩放和关闭浏览器的能力
3. navigator对象,提供关于浏览器的详尽信息
4. location对象,提供浏览器加载页面的详尽信息
5. screen对象,提供关于用户屏幕分辨率的详尽信息
6. performance对象,提供浏览器内存占用,导航行为和时间统计的详尽信息
7. 对cookie的支持
8. 其他自定义对象,如XmlHttpRequest和IE的ActiveXObject

# 第二章 HTML中的JavaScript

## \<Scripts>元素

### 属性

1. async:可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其 他脚本加载。只对外部脚本文件有效。
2. charset:可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不 在乎它的值
3. crossorigin:可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin= "anonymous"配置文件请求不必设置凭据标志。crossorigin="use-credentials"设置凭据 标志，意味着出站请求会包含凭据。
4. defer:可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。 在 IE7及更早的版本中，对行内脚本也可以指定这个属性。
5. integrity:可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI， Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错， 脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提 供恶意内容。
6. language:废弃。最初用于表示代码块中的脚本语言（如"JavaScript"、"JavaScript 1.2" 或"VBScript"）。大多数浏览器都会忽略这个属性，不应该再使用它。
7. src:可选。表示包含要执行的代码的外部文件。
8. type:可选。代替 language，表示==代码块中脚本语言的内容类型（也称 MIME类型）==。按照惯 例，这个值始终都是"text/javascript"，尽管"text/javascript"和"text/ecmascript" 都已经废弃了。JavaScript 文件的 MIME类型通常是"application/x-javascript"，不过给 type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有 "application/javascript"和"application/ecmascript"。==如果这个值是 module，则代 码会被当成 ES6模块，而且只有这时候代码中才能出现 import 和 export 关键字==。

### 放入Script的位置

1. 直接在HTML页面中行内script书写script

2. 在head标签内放入script,这样子做,一开始是为了方便和css一起进行管理,但是他也有缺点,如果需要加载的脚本数量特别多的话,那么用户会等待一段时间,会给用户带来非常不好的体验

3. 为了解决上述的问题,可以在body标签结束前,放入script内容

   ![image-20210825110443031](https://gitee.com/IU_czx/images/raw/master/img/image-20210825110443031.png)

4. 推迟执行脚本,加入defer这个属性,告诉浏览器,立即下载,但是把我推迟执行,执行顺序还是和原来一样,第一个推迟的脚本会在第二个推迟的脚本前执行

5. 异步执行脚本,加入async这个属性,告诉浏览器,会立即下载,但不能保证执行顺序,所以在异步脚本的加载过程中,不要有修改dom的操作,异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded,之前或之后

6. 动态执行脚本,即在脚本中使用DOM去动态的添加脚本,这种方式默认是以异步进行加载的,因为并不是所有浏览器都支持异步加载,所以将它设置为同步加载会比较好

   以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些 动态请求文件的存在，可以在文档头部显式声明它们：

   `<link rel="preload" href="XXX.js">`

## 行内代码和外部文件

> 最好使用外部文件
>
> 好处
>
> 1. **可维护性**。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存 所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML页面来编辑 代码。
> 2. **缓存**。浏览器会根据特定的设置缓存所有外部链接的 JavaScript文件，这意味着如果两个页面都 用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
> 3. **适应未来**。通过把 JavaScript放到外部文件中，就不必考虑用 XHTML或前面提到的注释黑科技。 包含外部 JavaScript文件的语法在HTML和XHTML中是一样的。

在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在 SPDY/HTTP2 中，
预请求的消耗已显著降低，以轻量、独立 JavaScript组件形式向客户端送达脚本更具优势。

在初次请求时，如果浏览器支持 SPDY/HTTP2，就可以从同一个地方取得一批文件，并将它们逐个放到浏览器缓存中。从浏览器角度看，通过 SPDY/HTTP2 获取所有这些独立的资源与获取一个大 JavaScript文件的延迟差不多。 

在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。 当然，这里假设浏览器支持 SPDY/HTTP2，只有比较新的浏览器才满足。如果你还想支持那些比较
老的浏览器，可能还是用一个大文件更合适。

## 文档模式

三种文档模式

1. 混杂模式
2. 标准模式
3. 准标准模式

混杂模式:让IE像 IE5一样（支持一些非标准的特性)

标准模式:让IE具有兼容标准的行为

准标准模式:这种模式下的浏览器支持很多标准的特性，但是没 有标准规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显).

## noscript元素

它将在下面两种情况下显示自己的内容(可以正常放入HTML元素内容)

1. 浏览器不支持脚本
2. 浏览器对脚本的支持被关闭

# 第三章语言基础

## 前言

ES5和ES6是目前市场上主流浏览器支持最好的

## 语法

### 区分大小写

### 标识符

1. 第一个字符必须是一个字母、下划线（_）或美元符号（$）； 

2. 剩下的其他字符可以是字母、下划线、美元符号或数字。
3. 规范采用驼峰大小写形式

### 严格模式

使用这个的目的主要是不破坏ECMAScript的语法

### 语句

最好每句话后面都加上分号,这样在某些情况下是可以提高性能的,因为解析器会尝试在合适的位置补上分号以纠正语法错误

### 关键字和保留字

![image-20210825113509686](https://gitee.com/IU_czx/images/raw/master/img/image-20210825113509686.png)



### 变量

ECMAScript变量是松散类型的,它可以保存任何类型的数据

1. var

   1. 使用var操作符定义的变量会成为包含它的函数的局部变量

      而在函数内部定义变量的时候,省略var操作符,这样子的值会变成全局变量

      因为是松散类型,所以可以用一条语句去声明三个不同的类型的数据

   2. 变量提升,使用var声明的变量,会提升到该函数作用域的顶部

2. let

   1. 使用let声明的是块作用域,而var声明的是函数作用域

   2. 并且let不会进行变量提升

   3. 这里引进一个专有名词:暂时性死区”（temporal dead zone)

   4. 在let声明之前的执行瞬间被称为"暂时性死区",任何在此阶段去引用后面才声明的变量,都会抛出引用错误
   5. 与var关键字不同,使用let声明的不会称为windows对象的属性
   6. 无法使用条件声明去使用let

3. const

   1. 它基本上与let差不多,但是它是在声明变量的时候必须要初始化变量,且不能修改变量,也就是声明常量,但是如果是引用对象的话,修改对象内的值,是不冲突的
   2. 在for循环内使用const去声明一个不会变的变量是可行的,对于forin 和 forof 循环特别有意义

## 数据类型

### 6种基本数据类型

1. null
2. undefined
3. 数值
4. String
5. boolean
6. symbol

### typeof操作符

使用typeof去区分各种数据类型

### undefined类型

详细代码写在了

01-JavaScript基础语法/03-undefined.js

即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的 同时进行初始化。这样，当 typeof 返回"undefined"时，你就会知道那是因为给定的变 量尚未声明，而不是声明了但未初始化。

### Null类型

> 逻辑上讲,null值表示一个空对象指针
>
> 所以在使用typeof时 返回的也是一个对象
>
> tips:在定义将来要保存对象的值时,建议使用null来初始化,这样以后能用null来进行比较
>
> undefined是由null值派生而来的,所以他们表面上是相等的(==)

| 数据类型  | 转换为true的值       | 转换为false的值 |
| --------- | -------------------- | --------------- |
| Boolean   | true                 | false           |
| String    | 非空字符串           | ""(空字符串)    |
| Number    | 非零数值(包括无穷值) | 0,NaN           |
| Object    | 任意对象             | null            |
| Undefined | N/A(不存在)          | undefined       |

### Number

Note:==八进制字面量在严格模式下是无效的,会导致JavaScript引擎抛出语法错误==

1. 浮点值

   * 对于非常大或非常小的数值,浮点值可以用科学计数法来表示

     eg:	let floatNum=3.125e7;   //等于31250000

   * 浮点值的精度高达17位,所以呢不要用测试特定的浮点值相加,会出大问题

2. 值的范围

   * 最小值是存在Number.MIN_VALUE中的,最大值是存在Number.MAX_VALUE中的
   * 任何超出值的数会被转换为infinity 正数:infinty 负数:-infinty
   * 要确定一个值是否为有限值 使用   ==isfinty==函数

3. NaN

   * 表示不是数字
   * 任何涉及NaN的操作始终返回NaN
   * NaN不包括NaN在内的任何值
   * 要想进行比较的话,得使用`isNaN()`这个函数

4. 数值转换规则(使用`Number()`函数)

   1. 布尔值   true=>1 false=>0
   2. 数值 直接返回
   3. null=>0
   4. undefined=>NaN
   5. 字符串
      1. 包含数字字符,包括数字前面带加,减号的情况下,会转换成一个十进制数值
      2. 包含有效的浮点值,则会转换为相应的浮点值(会忽略掉前面的0)
      3. 包含有效的16进制格式,如0xf,会转换成与该16进制值对应的十进制整数值
      4. 空字符串则返回为0
      5. 除了以上情况 其余情况全部返回为0
   6. 对象: 首先调用`valueof()`方法,如果转换结果是NaN,则调用toString()方法,再按照字符串的规则进行转换

5. parseInt

   接收两个参数: 数值 ,进制

   * 如果不传入第二个参数,第一个参数是什么进制,会根据进制进行转换为10进制
   * 传入第二个参数,那么第一个参数如果传入的是16进制,那么16进制的0x可以省略

6. parseFloat

   只能解析十进制

### String类型

> Note:==ECMAScript中的字符串是不可变的(immutable)==
>
> `let lang="Java"`
>
> `lang=lang+"Script"`
>
> 我们来分析下这个字符串的一个合并过程
>
> 这里，变量 lang 一开始包含字符串"Java"。紧接着，lang 被重新定义为包含"Java"和"Script"的组合，也就是"JavaScript"。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上 "Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用 了。

1. toString方法
   * 可以在toString()中接收一个参数,指定根据什么进制来转换
2. String()函数遵循如下规则
   1. 如果值有toString()方法,则调用该方法(不传参数)并返回结果
   2. 如果值是null,返回"null"
   3. 如果值是undefined,返回"undefined"
3. 模板字面量
   1. 模板字面量会保持反引号内部的空格
   2. 模板字面量可以插值
   3. 模板字面量标签函数(这一块看我写的例子,有例子看的更明白)
   4. 可以使用模板字面量直接获取原始的模板字面量内容(如换行符或Unicode字符),要使用String.raw标签函数,也可以通过标签函数中的第一个参数,即strings.raw属性取得每个字符串的原始内容

### Symbol类型

> 这个是ES6新增的一种原始类型,主要是用来确定属性的唯一性的,可以给对象的属性加上唯一的属性名,确保是唯一的,不会发生属性冲突的危险

1. 基本用法:声明时需要用symbol()函数初始化

   ```js
   /**
   	每个用Symbol声明的都是唯一的
   */
   const name=Symbol("可以传入一个描述性字符");
   ```

2. Symbol()不能与new关键字一起作为构造函数使用,如果确实想用符号包装对象,可以借用Object()函数

3. `Symbol.for()`

   上面说到,每个Symbol都是唯一的,所以要想共享的话呢,就必须得使用`Symbol.for()`方法,使用该方法之前,会先检查全局有没有注册这个实例,如果没有则会注册,如果注册过,则会进行一个重用

   全局注册表中的符号必须使用字符串键来创建,所以传给它的必须得是字符串
   
4. `Symbol.keyFor()`:这个是用来查询全局注册的Symbol,会输出`Symbol.for("字符串键")`中的 字符串键

5. 使用符号作为属性:凡是可以使用字符串或数值作为属性的地方,都可以使用符号

   包括 `Object.defineProperty()`/ `Object.defineProperties()`定义的属性

   对象字面量只能在**计算属性语法**中使用属性作为属性

   ```js
   let s1 = Symbol('foo'), s2 = Symbol('bar'), s3 = Symbol('baz'), s4 = Symbol('qux');
   let o = { [s1]: 'foo val'}; // 这样也可以：o[s1] = 'foo val';
   
   Object.defineProperty(o, s2, {value: 'bar val'});
   
   Object.defineProperties(o, { [s3]: {value: 'baz val'}, [s4]: {value: 'qux val'}});
   
   ```

6. 方法介绍

   1. Object.getOwnPropertyNames()返回对象实例的常规属性数组

      Object.getOwnPropertySymbols()返回对象实例的符号属性数组

      上面的这两种方法是互斥的

   2. Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述的对象

      Reflect.ownKeys()会返回两种类型的键

7. 因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。

   但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键
   
   ```js
   const s2 = Symbol("foo2");
   
   let o = {
       [Symbol("foo")]: "foo val",
       [Symbol("bar")]: "bar val",
       [s2]: "foo2 val",
       name: "czx",
   }
   
   let barSymbol = Object.getOwnPropertySymbols(o).find(symbol => symbol.toString().match(/bar/));
   let barSymbol2 = Object.getOwnPropertySymbols(o);
   console.log(o[Symbol("foo")]);
   console.log(barSymbol);
   console.log(barSymbol2);
   
   /**
    * 没有进行显示声明的symbol对象 只能通过遍历找到相应的属性键
    */
   ```
   
8. 常用的内置符号(后面的东西比较多,我就不看了,大部分听都没听过,等熟悉了再来补充)

   > note:所有的内置符号属性都是不可写,不可枚举的,不可配置的

### Object类型

> 每个Object实例都有如下属性和方法
>
> 1. constructor:用于创建当前对象的函数
> 2. hasOwnProperty:用于判断当前对象实例(不是原型)上是否存在给定的属性.要检查的属性名必须得是字符串
> 3. propertyIsEnumerable:用于判断当前属性是都否可以使用for-in枚举,必须是字符串
> 4. toLocaleString():返回对象字符串表示,该字符串反应对象所在的本地化执行环境
> 5. toString():返回对象的字符串表示
> 6. valueof():返回对象对应的字符串,数值或布尔值表示,通常与toString()返回值相同

## 操作符

1. 一元操作符

   1. ++(分前后)
   2. --(分前后)

2. 一元加和减

   1. +
   2. -

3. 位操作符

   1. 有符号整数:前31位表示整数值,第32位表示数值的符号 0正 1负
   2. 无符号整数只有正数,没有符号位
   3. 按位非:`~`表示,对数取反减一 返回数值的补数
   4. 按位与`&` 都是1返回1 一个为0返回0
   5. 按位或:`|`全为0才返回为0,其余情况返回为1
   6. 按位异或:`^`只有一个1的时候返回1,其余情况返回0
   7. 左移:`<<`会按照指定位数,将数值的所有位向左移动,左移 右边会空出5位 右边的会以0填充
   8. 有符号右移:`>>`会按照指定位数,将数值的所有位向右移动,同时会保留符号位,左边空出的会用符号位进行补充
   9. 无符号右移:`>>>`对于正数来讲没什么区别,但是对于负数的话,值会比原来大很多

4. 布尔操作符

   1. 逻辑与:`&&`
   2. 逻辑或:`||`
   3. 逻辑或:`!`

5. 乘性操作符

   1. `*`:	infinity*infinity=infinity
   2. `/`:   infinity / Infinity=NaN
   3. `%`:取模

6. 指数操作符

   `**`:表示指数操作符,等同于 Math.pow()

7. 加性操作符

   1. 加号:如果是 Infinity 加-Infinity，则返回 NaN；
   2. 减号:如果是 Infinity 减 Infinity，则返回 NaN。

8. 关系操作符

   1. <
   2. \>
   3. \>=
   4. <=

9. 相等操作符

   1. `==`:这个是等于:这个在比较前执行转换
   2. `===`:这个是全等:这个在比较前不执行转换
   3. 推荐使用全等,可以保证代码的完整性

10. 条件操作符:三元运算符 `? :`

11. 赋值操作符:

    1. 乘后赋值（*=） 

    2. 除后赋值（/=） 

    3. 取模后赋值（%=） 

    4. 加后赋值（+=） 

    5. 减后赋值（-=） 

    6. 左移后赋值（<<=） 

    7. 右移后赋值（>>=） 

    8. 无符号右移后赋值（>>>=）

12. 逗号操作符:`,`:最常用的是在一条语句当中同时声明多个变量

## 语句

1. if

2. do-while

3. while

4. for

   ```js
   for(;;){
       //这么写表示无穷循环
   }
   
   for(;i<count;){
       //只有表达式的话,就变成了while循环
   }
   ```

   

5. for-in

   > 用于枚举对象中的==非符号==键属性
   >
   > ECMAScript中的对象的属性是无序的,所以for-in语句不能保证返回对象属性的属性

6. for-of

   > for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素

7. 标签语句:我代码里写了

8. break和continue

9. with:不推荐使用,不方便调试

10. switch

## 函数

> 特点:在ECMAScript中的函数不需要指定是否返回值
>
> 最佳实践:要么返回值,要么不返回值,只在某个条件下返回值的函数会带来麻烦,尤其是调试的时候

# 第五章 基本引用类型

## 前言

> 在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构

## 01-Date

### <span style="color:skyblue">基本使用</span>

1. `let now=new Date()`;

   在不给Date构造函数传递参数的情况下,创建的对象将保存当前日期和时间

2. `Date.Parse()`

   接收一个表示日期的字符串参数,这个就是用来创建一个对应日期的对象

   ![image-20210907182450049](https://gitee.com/IU_czx/images/raw/master/img/Date.Parse()%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.png)

   如果传给`Date.parse()`的字符串并不表示日期,则该方法会返回NaN

   直接在`new Date()`传递日期字符串,会隐式调用`Date.parse()`

3. `Date.UTC()`

   传递参数:只有年和月是必须的

   1. 年
   2. 0起点月数(1月是0,往后类推)
   3. 日(1~31)
   4. 时(0~23)
   5. 分,秒,毫秒

   同样的,如果你直接传递到`new Date()`  会隐式调用`Date.UTC()`

4. `Date.now()`

   ```js
   let start=Date.now();
   //do something
   let end=Date.now();
   result=start-end
   ```

   可以利用这个方法去分析下代码

5. 日期格式化方法

   ![image-20210907183222337](https://gitee.com/IU_czx/images/raw/master/img/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95.png)

6. 日期/时间组件方法

   ![image-20210907183404094](https://gitee.com/IU_czx/images/raw/master/img/%E6%97%A5%E6%9C%9F/%E6%97%B6%E9%97%B4%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95.png)

## 02-RegEXP

### 创建方法

1. `let expression = /pattern/flags;`

2. `let expression = new RegExp()`

   这里面可以传递一个新的正则表达式实例

   也可以传递一个已有的正则表达式实例

   第二个参数是`匹配模式标记`,你可以相对应的修改原来的`匹配模式标记`

### 匹配模式标记

1. `g`:全局模式,表示查找字符串的全部内容,而不是找到第一个匹配的内容就结束
2. `i`:不区分大小写,表示在查找匹配时忽略pattern和字符串的大小
3. `m`:多行模式,表示查找到一行文本末尾时会继续查找
4. `y`:粘附模式,表示只查找从`lastIndex`开始及之后的字符串
5. `u`:Unicode模式,启用Unicode匹配
6. `s`:dotAll模式,表示元字符,匹配任何字符(包括`\n`或`\r`)
7. **元字符**包含`( { [ \ ^ $ | ? * + . ] } )`

### RegExp实例属性(用着不多)

![image-20210907185000254](https://gitee.com/IU_czx/images/raw/master/img/RegExp%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7.png)

### RegEXP实例方法

1. RegExp实例的方法是`exec()`

   只接受一个参数,即要应用模式的字符串,如果找到了匹配项,则返回包含第一个匹配信息的数组,没找到匹配项,则返回null

   返回的结果包含两个额外的属性:`index`和`input`

   index是字符串中匹配模式的起始位置,input是我们放入的字符串

2. `test()`

   只测试字符串是否符合模式匹配,不关心返回什么

## 03-原始值包装类型

> ECMAScript 提供了3种特殊的引用类型：Boolean、Number 和 String
>
> 在以读模式访问字符串值的时候,后台会执行以下3步
>
> 1. 创建一个String类型的实例
> 2. 调用实例上的特定方法
> 3. 销毁实例
>
> 通过new实例化引用类型后,得到的实例会在离开作用域时被销毁
>
> 自动创建的原始值包装对象则只存在于访问它的那行代码执行期间
>
> tips:
>
> | new出来的                 | 直接通过Number,String,Boolean转型的 |
> | ------------------------- | ----------------------------------- |
> | instanceof 测出来的是true | instanceof 测出来的是false          |
> | typeof是对象              | typeof是对应基本类型                |

### Boolean

其他的感觉没啥记的

> 所有对象在布尔表达式中都会自动转换为true
>
> ```js
> let falseObject = new Boolean(false); 
> let result = falseObject && true;
> //所以这答案是true
> ```

### Number

<h3 style="color:skyblue">方法</h3>

重写方法

1. `valueof()`:返回Number对象表示的原始数值
2. `toLocaleString`
3. `toString()`:传递一个进制数,根据进制转换,也可以不传,默认10进制

自己的方法

1. `toFixed`:保留多少位数的
2. `toExponential()`:返回科学计数法
3. `toPrecison()`方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法
   形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）
4. `isInteger()`:鉴别保存的数值是否为整数
5. `isSafeInteger()`:鉴别数字是否是在IEEE754格式上的安全数

### String

<h3 style="color:skyblue">方法</h3>

| `valueof()`                          | 继承(返回字符串本身)                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `toLocalString()`                    | 继承(返回字符串本身)                                         |
| `toString`                           | 继承(返回字符串本身)                                         |
| `length`                             | 返回字符串长度                                               |
| `charAt()`                           | 返回给定索引位置的字符                                       |
| `charCodeAt()`                       | 可以查看指定码元的字符编码,这个方法返回指定索引位置的码元值，索引以整数指定 |
| `normalize()`                        | 某些 Unicode 字符可以有多种编码方式,使用时传入"NFD"、"NFC"、"NFKD"或"NFKC"中的一个,进行Unicode代码的规范化 |
| `concat()`                           | 用于将一个或多个字符串拼接成一个新字符串,多个字符串用`+`更方便 |
| `slice()`                            | 截取字符串,第一个参数开始位置,第二个参数结束位置,截取字符串不包括结束位置 |
| `substring()`                        | 截取字符串,第一个参数开始位置,第二个参数结束位置,截取字符串不包括结束位置 |
| `substr`                             | 截取字符串,第一个参数是开始位置,第二个参数是截取字符串数量   |
| `indexof()`                          | 从前往后找字符,返回索引                                      |
| `lastIndexof()`                      | 从后往前找字符,返回索引                                      |
| `startWith()`                        | 查找字符,有的话返回true.,从0开始,可以传入第二个参数,确定从哪找起 |
| `endWith()`                          | 检查开始于索 引(string.length - substring.length)的匹配项,这个subtring.length是你要查找的字符长度 |
| `includes()`                         | 检查整个字符串,可以传入第二个参数,确定从哪找起               |
| `trim()`                             | 删除前、 后所有空格符，再返回结果                            |
| `repeat()`                           | 这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。 |
| `padStart()`                         | 如果小于指定长度，则在相应一边填充字符,填充在前,接收参数:填充字符 |
| `padEnd()`                           | 如果小于指定长度，则在相应一边填充字符,填充在后,接收参数:填充字符 |
| `toLowerCase() toLocaleLowerCase()`  | 让字母小写,如果不知道代码涉及什么语言，则最好使用地 区特定的转换方法 |
| `toUpperCase()和toLocaleUpperCase()` | 让字母大写,如果不知道代码涉及什么语言，则最好使用地 区特定的转换方法 |
| `match()`                            | match()方法返回的数组与 RegExp 对象的 `exec()`方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。 |
| `search()`                           | 这个方法返回模式第一个匹配的位置索引，如果没找到则返回`-1`   |
| `spilt()`                            | 这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。 |
| `replace`                            | 这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是 一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串 |
| `localeCompare()`                    | 这个方法比较两个字符串大小,根据字符串字母表顺序              |

